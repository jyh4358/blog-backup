# AOP

애플리케이션 로직은 크게 핵심 기능과 부가 기능으로 나눌 수 있다.

- 핵심 기능 : 해당 객체가 제공하는 고유의 기능
- 부가 기능 : 핵심 기능을 보조하기 위해 제공되는 기능


<br/>

애플리케이션에서 부가 기능을 적용하는 클래스가 여러 개가 있으면 각 클래스마다 동일한 코드를 추가해야 하는 단점이 있다. 부가 기능을 별도의 유틸리티 클래스로 만들어 사용한다고 해도 해당 유틸리티 클래스를 호출하는 코드가 결국 핵심 기능 로직에 필요하게 된다. 

더 큰 문제는 부가 기능의 수정이 발생했을 때 이다. 부가 기능을 수정하게 된다면 부가 기능을 사용하는 모든 클래스를 찾아 수정해야 하는 문제가 발생한다. 이러한 과정에서 예기치 않은 문제가 발생하거나 각 클래스를 찾아 수정해야 하기 때문에 유지 보수가 힘들다는 문제가 있다.

소프트웨어 개발에서 중복 되는 코드는 변경 지점이 하나가 될 수 있도록 모듈화를 잘 시켜야 한다. 하지만 부가 기능처럼 특정 로직을 애플리케이션 전반에 적용하는 문제는 일반적으로 OOP 방식으로는 해결하기 어렵다.

이러한 문제를 해결해주는 것이 바로 AOP(Aspect-Oriented 
Programming)이다.


## Aspect

Aspect를 이용하면 부가 기능을 핵심 기능에서 분리하여 관리할 수 있다. 또한 부가 기능을 어디에 적용할지도 설정할 수 있다. 이렇게 부가 기능을 분리한 것과 부가 기능을 어디에 적용할지 선택하는 기능을 합해서 하나의 모듈로 만들었는데 이것이 바로 **Aspect**이다. Aspect는 쉽게 이야기해서  부가 기능과, 해당 부가 기능을 횡단 관심사로 어디에 적용할지 정의한 것이다.

 ![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/springaop.JPG)


<br/>

### @Aspect 프록시

자동 프록시 생성기(`AnnotationAwareAspectJAutoProxyCreator`)는 Advisor를 자동으로 찾아와서 필요한 곳에 프록시를 생성하고 적용해주는데 추가로 `@Aspect`를 찾아 Advisor를 적용한 프록시를 생성하는 기능도 가지고 있다. 그래서 앞에 AnnotationAware(애노테이션을 인식하는)가 붙어 있는 것이다.

<br/>

자동 프록시 생성기가 하는 일
- `@Aspect`를 찾아 Advisor로 변환해서 저장
- Advisor를 기반으로 프록시 생성

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/springaop2.JPG)

<br/>

자동 프록시 생성기의 동작 과정

1. 생성 : 스프링 빈 대산이 되는 객체를 생성(@Bean, 컴포넌트 스캔 모두 포함)
2. 전달 : 생성된 객체를 빈 후처리기에 전달
3. Advisor 빈 조회 : 스프링 컨테이너에서 Advisor 빈을 모두 조회
4. @Aspect 조회 : @Aspect 어드바이저 빌더 내부에 저장된 Advisor 조회
5. 프록시 대상 체크 : Advisor에 포함되어 있는 포인트컷으로 프록시 적용 대상인지 판단
6. 프록시 생성 : 프록시 적용 대상이면 프록시를 생성하고 프록시를 반환, 프록시 적용 대싱이 아니라면 원본 객체를 반환
7. 빈 등록 : 반환된 객체(프록시 or 원본 객체)를 스프링 빈으로 등록

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/springaop3.JPG)

<br/>
<br/>

## AOP 적용 방식

AOP를 사용하면 핵심 기능과 부가 기능이 코드상 완전히 분리되어서 관리 되며 AOP를 사용할 때 부가 기능 로직이 실제 로직에 추가할 수 있는 방법이 다음과 같은 3가지 방식이 있다.

- 컴파일 시점
    - .java 소스 코드를 컴파일러를 사용해서 .class를 만드는 시점에 부가 기능 로직을 추가
    - AspectJ가 제공하는 특별한 컴파일러를 사용해야 한다.
    -  실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. 
    - AspectJ를 직접 사용해야 한다.

- 클래스 로딩 시점
    - 클래스 로더에 의하여 JVM에 로드되기 전에 특별한 클래스 로더 조작기를 이용하여 부가 기능 로직을 추가한 뒤 JVM에 로드한다.
    - 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. 
    - AspectJ를 직접 사용해야 한다

- **런타임 시점(프록시)**
    - 프록시를 이용하여 부가 기능을 적용한 방법 
    - 실제 대상 코드는 그대로 유지되며 대신에 프록시를 통해 부가 기능이 적용된다. 따라서 항상 프록시를 통해서 부가 기능을 사용할 수 있다. 
    - 스프링 AOP는 이 방식을 사용한다.
    -  스프링은 AspectJ의 문법을 차용하고 프록시 방식의 AOP를 적용하는 방법으로 AspectJ를 직접 사용하는 것이 아니다

<br/>
<br/>

## AOP 용어 정리

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/springaop4.JPG)

- 조인 포인트(Join Point)
    - **어드바이스가 적용될 수 있는 위치**
    - 추상적인 개념으로 AOP를 적용할 수 있는 모든 지점을 말한다.
    - 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한된다.

- 포인트컷(Pointcut)
    - **조인 포인트 중에서 어드바이스가 적용될 위치를 설정**
    - AspectJ 표현식을 사용하여 지정한다.
    - 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능하다.

- 타켓(Target)
    - 어드바이스를 받는 객체, 포인트컷으로 결정되며 핵심 기능이 있는 객체를 말한다.

- 어드바이스(Advice)
    - 부가 기능
    - 특정 조인 포인트에서 Aspect에 의해 취해지는 부가 기능
    - Around(주변), Before(전), After(후)등 다양한 종류의 어드바이스가 있다.

- 애스펙트(Aspect)
    - Advise + Pointcut을 모듈화 한 것을 말한다.
    - Spring AOP에서 사용하는 `@Aspect`
    - 애스펙트 안에 여러 개의 어드바이스와 포인트 컷이 존재한다.

- 위빙(Weaving)
    - Pointcut으로 결정한 Target의 Join Point에 Advise를 적용하는 것을 말한다.
    - 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있다.

- AOP 프록시
    - AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 **JDK 동적 프록시 또는 CGLIB 프록시**이다.


