# 6장 메시지와 인터페이스

객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다고 생각하는 것이다. 하지만 이러한 생각은 잘못된 생각이다. 클래스는 단지 도구일 뿐이다. 즉, 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계를 하게 될 가능성이 높아지게 된다.

따라서 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 **협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다.** 퍼블릭 인터페이스를 이용하여 유연하고 재사용이 가능한 설계를 통해 객체지향 코드를 설계하는 것이 중요하다.

<br/>
<br/>

## 01. 협력과 메시지

### 클라이언트-서버 모델

객체들은 서로 메시지를 주고 받으며 협력을 하게 되는데 이러한 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 **클라이언트-서버 모델**이다.

- 클라이언트 - 메시지를 전송하는 객체(예시 : Screening)
- 서버 - 메시지를 수신하는 객체(예시 : Movie)

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/6%EC%9E%A51-1.png)

<br/>

또한 협력의 관점에서 객체는 수신하는 메시지의 집합과 외부의 객체에게 전송하는 메시지의 집합으로 구성된다.

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/6%EC%9E%A51-2.png)

<br/>

### 메시지와 메시지 전송

메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

- 메시지 전송, 메시지 패싱
    - 한 객체가 다른 객체에게 도움을 요청하는 것
- 메시지 전송자 == 클라이언트
    - 메시지를 전송하는 객체
- 메시지 수신자 == 서버
    - 메시지를 수신하는 객체


메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 **메시지 수신자, 오퍼레이션명, 인자**의 조합이다

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/6%EC%9E%A51-3.png)

<br/>

### 메시지와 메서드

메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드**라고 부른다.  중요한 것은 코드 상에서 동일한 이름의 수신자(condition)에게 동일한 메세지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다. (추상화를 통한 동적 바인딩)

이처럼 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만들어 준다.

<br/>

### 퍼블릭 인터페이스와 오퍼레이션

외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있는데 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부르며 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.

**오퍼레이션**은 수행 가능한 어떤 행동에 대한 추상화이다. 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.

그에 비해 메시지를 수신했을 때 실제로 실행되는 코드를 **메서드**라고 부른다. 

- DiscountCondition 인터페이스의 isSatisfiedBy : 오퍼레이션
- SequenceCondition 구현체의 isSatisfiedBy : 메서드

<br/>

객체가 다른 객체에게 메세지를 전송하면 런타임 시스템은 메세지 전송을 오퍼레이션 호출로 해석하고 메세지를 수신한 객체의 실제 타입을 기반으로 메서드를 찾아 실행한다

![첨부 이미지](https://file-upload-store-jdd.s3.ap-northeast-2.amazonaws.com/6%EC%9E%A51-4.png)

<br/>

### 시그니처

오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 **시그니처**로 부른다. 

<br/>
<br/>

## 02. 인터페이스와 설계 품질

좋은 인터페이스는 **최소한의 인터페이스와 추상적인 인터페이스**라는 조건을 만족해야 한다.

- 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만을 인터페이스에 포함
- 추상적인 인터페이스 : 어떻게 수행하는지가 아닌 무엇을 하는지 표현

이러한 조건을 만족할 수 있도록 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방식을 따르는 것이다. 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 포함되는 것을 방지하며 객체가 메시지를 선택하는 것이 아닌 메시지가 객체를 선택하게 함으로써 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.

책임 주도 설계 방법 이외에도 훌륭한 인터페이스가 가지는 공통적인 특징을 아는 것이 올바른 설계에 도달할 수 있도록 제공한다.

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

<br/>

### 디미터 법칙

```
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
        Movie movie = screening.getMovie();

        boolean discountable = false;
        for (DiscountCondition condition : movie.getDiscountConditions()) {
            if (condition.getType() == DiscountConditionType.PERIOD) {
                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek())
                    && condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0
                    && condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
            } else {
                discountable = condition.getSequence() == screening.getSequence();
            }
            if (discountable) { 
            	break; 
            }
        }
        ...
    }
}
```


해당 코드의 큰 문제는 ReservationAgency와 인자로 전달된 Screening사이의 결합도가 너무 높아 Screening의 내부 구현이 변경될 때마다 ReservationAgency도 함께 변경된다. 

위 처럼 협력하는 객체으 ㅣ내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 **디미터 법칙**이다. 간단하게 설명하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것을 말한다.    

<br/>

디미터 법칙을 적용한 코드는 다음과 같다.

```
public class ReservationAgency {
    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = screening.calculateFee(audienceCount);
        return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
    }
}
```

위 코드를 보면 ReservationAgency가 Screening 내부의 Movie에 접근하는 대신 Screening에게 직접 요금을 게산하도록 요청했다. 즉, 요금을 계산하는 데 필요한 정보를 잘 알고 있는 Screening에게 요금을 계산할 책임을 할당한 것이다.

<br/>

### 묻지 말고 시켜라

디미터 법칙을 적용하면 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 것을 강조한다. 이로써 **객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스레 정보와 행동을 동일한 클래스 안에 두게 된다.** 


<br/>

### 의도를 드러내는 인터페이스

```
public class PeriodCondition {
    public boolean isSatisfiedByPeriod(Screening screening) { ... }
}

public class SequenceCondition {
    public boolean isSatisfiedBySequence(Screening screening) { ... }
}
```

위 코드를 보면 다음과 같은 문제가 있다.

1. 메서드의 내부 구현에 대해 알아야 한다.
    - 위 두개 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 것을 알기 어렵다.
2. 메서드 수준에서 캡슐화를 위반한다.
    - 메서드 명으로 협력하는 객체의 종류를 알도록 강제한다. 이로 인해 참조 객체를 변경할 경우 메서드 명도 변경해야 하는 문제가 발생한다.

<br/>

따라서 인터페이스의 오퍼레이션은 '어떻게'가 아닌 '무엇을' 수행하는지 드러내도록 지으되 클라이언트 관점에서 동일한 작업을 수행하는 경우 추상화 하여 하나의 타입 계층으로 묶어 설계를 유연하게 만들어야 한다.

이처럼 어떻게 하느냐가 아닌 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 **선택자(Intention Revealing Selector)** 라고 부른다.

```
public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) { ... }
}

public class SequenceCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) { ... }
}

public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```

<br/>
<br/>

## 03. 원칙의 함정

위에서 알아본 디미터 법칙과 묻지 말고 시켜라 스타일은 객체의 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 훌륭한 설계 원칙이지만 절대적인 법칙은 아니다. 잊지 말아야 하는 사실은 설계가 트레이드오프의 산물이라는 점이다. 즉, 무조건적으로 원칙을 따르다 보면 설계는 일관성을 잃어버리고 코드는 무질서 속에 파묻히게 된다.

따라서 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하는 것도 좋은 설게라고 볼 수 있다. 단, 언제 원칙을 적용할지, 적용하지 않을지에 대한 판단을 할 수 있는 능력을 기르는 것이 중요하다. 

<br/>

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

자바 8의 Stream은 기본적으로 기차 충돌을 초래하기 때문에 디미터 법칙을 위반한다고 생각할 수 있다.

```
IntStream.of(1, 15, 3, 9).filter(x -> x > 10).distinct.count();
```

위 코드에서 of, filter, distinct 메서드는 모두 IntStream이라는 동일한 클래스의 인스턴스를 반환한다. 즉, 이들은 IntStream의 인스턴스를 또 다른 IntStream의 인스턴스로 변환한다. 

디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다. 위 코드는 단지 IntStream을 다른 IntStream으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.

<br/>

### 결합도와 응집도의 충돌

묻지 않고 시켜야 하지만 때로는 물으려는 객체가 데이터인 경우가 있다. 바로 자료구조인 경우이다. 자료구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.

앞서 말했지만 원칙을 맹신하지 않고, 적용하기 전 적절한 상황과 적절한 상황을 판단하는 안목을 길러야 한다.

<br/>
<br/>

## 04. 명령-쿼리 분리 원칙

명령-쿼리 분리 원칙은 퍼블릭 인터페이스을 정의할 때 참고할 수 있는 지침을 제공한다. 다음 명령-쿼리 분리 원칙을 이해하기 위한 몇 가지 용어를 살펴보자.

- 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈, 프로시저와 함수로 구분
    - 프로시저 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴(부수효과를 발생 O, 값 반환 X)
    - 함수 : 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴(부수효과를 발생 X, 값 반환 O)
- 명령 : 객체의 상태를 수정하는 오퍼레이션
- 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션

명령은 프로시저와 동일하고, 쿼리는 함수와 동일하다.

<br/>

명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다. **어떠한 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.** 따라서 명령과 쿼리를 분리하기 위해서는 다음과 같은 두 가지 원칙을 준수해야 한다.

- 객체의 상태를 변경하는 명령은 반환 값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

<br/>


### 책임에 초점을 맞춰라

 
책임 주도 설계 방법에 따라 메세지가 객체를 결정하게 하면 앞서 설명한 디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스, 명령-쿼리 분리 원칙에 긍정적인 영향을 미칠 수 있다.


- 디미터 법칙
    - 협력이라는 컨텍스트안에서 객체보다 메세지를 먼저 결정하면 수신할 객체를 알지 못한 상태에서 메세지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어져 구조적인 결합도를 낮출 수 있다.

- 묻지 말고 시켜라
    - 클라이언트 관점에서 메세지를 먼저 선택하기 때문에 필요한 정보를 물을 필요없이 원하는 것을 표현한 메세지만 전송하면 된다.

- 의도를 드러내는 인터페이스
    - 메세지를 먼저 선택한다는 것은 메세지를 전송하는 클라이언트 관점에서 메세지의 이름을 정한다는 것이기 때문에 클라이언트가 무엇을 원하는지 그 의도가 분명히 드러날 수 밖에 없다.

 - 명령-쿼리 분리 원칙
     - 메세지를 먼저 선택한다는 것은 협력이라는 컨텍스트안에서 객체의 인터페이스에 관해 고민하기 한다는 것이기 때문에 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.
