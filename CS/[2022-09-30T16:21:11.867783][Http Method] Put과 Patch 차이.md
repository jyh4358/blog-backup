# Put과 Patch 차이

이번에 면접에서 받은 질문이 있었다.

면접관 : *Http Method 종류를 알고 있나요?*

나 : *GET, POST, PUT, DELETE가 있고 Get 메소드는 주절주절..~*

면접관 : *PUT 메서드 말고 다른 메서드에 대해서도 알고있나요?*

나 : *네, PATCH가 있으며 ...(이 부분에서 잘못 대답), 그래서 PATCH를 사용하지 않았습니다* 

...(대화대화)

면접관 : *무조껀 Patch메서드를 사용하지 않는게 아닌 회사의 상황, 컨벤션 등에 따라서 Put 메서드와 Patch 메서드를 사용할 수 있어요*


<br/>

면접을 본 후 며칠 뒤에 다시 기억을 떠올린거라 정확하진 않지만 대략적인 질의응답은 위와 같았다. 면접 본 이후에 Put과 Patch 메서드의 차이점에 대해 생각해보았는데 어느 메서드가 전체 수정을 하고 어느 메서드가 부분 수정을 하는지, 또 이와 관련된 멱등성이 뭔지 머리에서 정리가 안되어 Put과 Patch의 차이점에 대해 알아볼려고 한다.

<br/>
<br/>

## REST API

우선 PUT과 PATCH의 차이점를 알아보기 전에 REST API에 대해 간단하게 집고 넘어가자. REST API란 자원을 URI로 표현하고 자원에 대한 **행위**를 HTTP Method로 표현하여 설계한 시스템을 말한다. 

여기서 주의 깊게 봐야 하는건 **행위**이다. REST API는 일관된 인터페이스(GET, POST, PUT, PATCH, DELETE)를 사용하기 때문에 resource(자원)과 인터페이스를 보고 그 행위를 알 수 있게 된다.

간단하게 행위에 대해 정리하면

- GET : 조회
- POST : 등록
- PUT, PATCH : 수정
- DELETE : 삭제

와 같은데 위와 같이 일관된 인터페이스를 통해 각 메서드가 어떤 행위를 하는지 쉽게 파악할 수 있게 된다.

<br/>

만약 HTTP Method의 행위가 지켜지지 않으면 어떻게 될까?

GET 메서드로 값을 등록하고, POST 메서드로 값을 조회하거나 GET 메서드로 CRUD 작업을 모두 수행한다거나 하면 우리는 해당 자원과 메서드를 보고 해당 API가 어떤 작업을 수행하는지 모르게 된다.

그렇기 때문에 REST API를 사용함으로서 resource(자원)에 대한 행위를 일관된 인터페이스를 사용하여 아키텍처 스타일을 파악할 수 있게 된다. 

자, 이제 PUT과 PATCH의 차이점에 대해서 알아보자. 다시 한번 말하지만 **행위**에 집중하길 바란다.


## PUT과 PATCH의 정의

### PUT - 생성, 대체

<br/>

> The HTTP PUT request method creates a new resource or replaces a representation of the target resource with the request payload.

HTTP PUT 메서드는 요청 페이로드를 사용하여 새로운 리소스를 생성하거나 대상 리소스를 나타내는 데이터를 대체합니다.

- 해당 리소스가 존재하지 않으면 **생성**

- 해당 리소스가 존재한다면 요청 값으로 데이터를 **대체**

<br/>

### PATCH - 부분 수정

<br/>

> The HTTP PATCH request method applies partial modifications to a resource.

HTTP PATCH 메서드는 리소스의 부분적인 수정을 적용한다.(부분 수정을 한다)

- 해당 리소스가 존재한다면 요청 값으로 데이터를 **부분 수정**

<br/>
<br/>

## PUT과 PATCH 차이점

위에 정의에서 알 수 있듯이 행위의 차이점이 존재한다.

- PUT : 생성 및 대체
- PATCH : 부분 수정

<br/>

이러한 행위의 차이점으로 인해 어떻게 달라지는지 알아보자.
(여기서 중요한 점은 행위에 맞춰 개발자가 PUT, PATCH API를 구현했다는 가정하에 읽기 바란다)

<br/>

### 차이점 1 - Update 관점

다음과 같은 resource가 존재한다고 가정하여 Update(수정)하는 상황

| id | name | email |
| --- | --- | --- |
| 100 | 손오공 | Ogong@gmail.com |


<br/>

**PUT**

- 해당 리소스가 존재할 경우 대체(모든 데이터 포함)

```
1. 
PUT /member/1
{
    name : 손오공,
    email : Ogong@naver.com
}
```

요청에 따른 resource의 변화

| id | name | email |
| --- | --- | --- |
| 100 | 손오공 | Ogong@naver.com |

<br/>

- 해당 리소스가 존재할 경우 대체(모든 데이터 미포함)
    - 예시에서 요청 데이터에 name이 미포함되었기 때문에 null값으로 대체 된다.

```
2. 
PUT /member/1
{
    email : Ogong@naver.com
}
```

요청에 따른 resource의 변화

| id | name | email |
| --- | --- | --- |
| 100 | null| Ogong@naver.com |

<br/>

- 해당 리소스가 존재하지 않을 경우 생성
- 이 역시 데이터의 일부만 보낼 경우 안 보낸 데이터는 null값으로 들어가게 된다.

```
3.
PUT /member/200
{
    name : 손오천,
    email : son5000@gamil.com
}
```

요청에 따른 resource의 변화

| id | name | email |
| --- | --- | --- |
| 100 | 손오공 | Ogong@gmail.com |
| 200 | 손오천| son5000@gmail.com |

<br/>
<br/>


**PATCH**

- 해당 리소스가 존재할 경우 수정(모든 데이터 포함)

```
1. 
PATCH /member/1
{
    name : 손오공,
    email : Ogong@naver.com
}
```

요청에 따른 resource의 변화

| id | name | email |
| --- | --- | --- |
| 100 | 손오공 | Ogong@naver.com |

<br/>

- 해당 리소스가 존재할 경우 수정(모든 데이터 미포함)
    - 요청 데이터로 넘어온 데이터만 부분 수정이 이루어진다.

```
2. 
PATCH /member/1
{
    email : Ogong@naver.com
}
```

요청에 따른 resource의 변화

| id | name | email |
| --- | --- | --- |
| 100 | 손오공| Ogong@naver.com |

<br/>

- 해당 리소스가 존재하지 않을 경우 서버는 오류를 응답한다.

```
3.
PATCH /member/200
{
    name : 손오천,
    email : son5000@gamil.com
}
```

<br/>
<br/>

### 차이점 2 - 멱등성 관점

<br/>

**멱등성이란?**

*동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다.*

<br/>

아주 간단한 예시로 들면 GET 메서드는 여러번 수행하여도 항상 같은 결과물을 반환하기 때문에 멱등성을 가진다고 할 수 있지만 POST 메서드는 여러번 수행하게 되면 수행된 만큼 리소스를 생성하기 때문에 멱등성이 성립하지 않는다고 볼 수 있다.

<br/>
<br/>

**PUT - 멱등성을 갖는다.**

PUT 메서드는 위에서 설명했듯이 **대체**를 하는 행위를 기반으로 한다. 즉, PUT 요청을 여러번 수행하여도 같은 값을 대체하기 때문에 서버의 상태가 항상 동일하므로 멱등성을 갖는 HTTP Method이다.

여기서 중요한 점은 **서버의 상태**이다. 최초 요청할 때 해당 resource가 없을 시 resource를 만들고 201(Created) 상태코드를 응답를 응답하고, 재요청 시 데이터를 대체한 후 200(OK) 혹은 204(No Content)를 응답하게 된다. 어떻게 보면 다른 응답 코드를 반환하기 때문에 멱등성에 위반한 것처럼 보이지만 서버의 상태, 즉 resource를 보면 같은 결과를 갖는다는 것을 알 수 있다. 따라서 서버의 상태를 보면 동일하므로 멱등성을 가진다고 볼 수 있다.

<br/>
<br/>

**PATCH - 멱등성을 가질 수도, 가지지 않을 수 도 있다.**

이게 뭔 말인가 싶을 것이다. 하지만 말 그대로이다. 그 이유는 개발자가 구현한 로직에 따라 달라진다. 

PATCH는 위에서 설명했듯이 **수정**의 행위를 하는 메서드이다. 즉, 요청 데이터를 가지고 resource의 값을 수정하는데 이 때 해당 로직에 따라 멱등성을 가질 수도, 가지지 않을 수도 있다.

- 요청 데이터를 그대로 resource를 수정할 경우<br/> => **멱등성을 갖는다**
    - 요청 데이터를 그대로 해당 resource를 수정하기 때문에 요청을 여러번 하게 되어도 항상 서버의 상태(resource의 값)이 동일

- 요청 데이터를 가지고 가공처리를 하여 resource를 수정할 경우<br/> => **멱등성을 갖지 않는다**
    - 요청 데이터를 가공하여 resource를 수정하기 때문에 요청을 여러번 하게 될 경우 가공된 값으로 수정되기 때문에 서버의 상태는 요청할 때마다 달라짐


<br/>

위 글을 읽고도 이해가 잘 안될 수 있으니 예시를 들어 설명하자면

```
// PATCH : /member/{id}      해당 멤버의 요청 데이터 age 값만큼 member.age 증가

PATCH /member/100
{
    age : 2
}
```
 
위와 같이 PATCH의 API 요청을 할 경우 요청 데이터인 age 값 만큼 Member.age를 더해주도록 구현했다면 어떻게 될까?

기존의 리소스

| id | name | age |
| --- | --- | --- |
| 100 | 손오공| 20 |

<br/>

요청 1번 했을 경우

| id | name | age|
| --- | --- | --- |
| 100 | 손오공| 22 |

<br/>

요청 2번 했을 경우

| id | name | age|
| --- | --- | --- |
| 100 | 손오공| 24 |


위와 같이 요청을 할 때마다 나이가 증가하여 서버의 상태가 동일하지 않기 때문에 멱등성이 갖지 않게 된다.


<br/>
<br/>

## 정리

결국은 update만 보았을 때 같은 작업을 수행한다고 할 수 있지만 **행위**에 따라 사용하는 메서드가 PUT과 PATCH로 나뉜다는 것이다.

사용자로부터 resource에 대한 모든 데이터를 받아 **대체**를 할 경우에는 PUT 메서드를, 

사용자로부터 resource의 특정 데이터만 받아 **수정**을 할 경우에는 PATCH 메서드를,

사용한다고 볼 수 있다.

<br/>

즉, 해당 요청을 어떤 행위를 하냐에 따라 PUT, PATCH 메서드를 정하면 된다. 

